<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Retro Lunar Lander</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }

    .hint {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: #8cff8c;
      font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      opacity: 0.75;
      user-select: none;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div class="hint">←/→ rotate • SPACE thrust • R retry (new hills) • ESC pause</div>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      // --- Resize (retro internal resolution)
      let W = 960, H = 540;
      function resize() {
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        W = 960; H = 540;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener("resize", resize);
      resize();

      // --- Input
      const keys = new Set();
      window.addEventListener("keydown", (e) => {
        if (["ArrowLeft", "ArrowRight", "Space", "Escape", "KeyR"].includes(e.code)) e.preventDefault();
        keys.add(e.code);
        if (e.code === "Escape") paused = !paused;
        if (e.code === "KeyR") startNewLevel();
      });
      window.addEventListener("keyup", (e) => keys.delete(e.code));

      // --- Game constants (YOUR DEFAULTS)
      const GREEN = "#7CFF7C";
      const DIM = "rgba(124,255,124,0.15)";
      const GRAVITY = 0.0009;          // px/frame^2
      const ROT_SPEED = 0.005;         // rad/frame
      const THRUST = 0.002;            // acceleration magnitude
      const FUEL_BURN = 1.8;           // per frame while thrusting
      const MAX_FUEL = 100000;

      const SAFE_VY = 0.08;            // px/frame (was 0.15)
      const SAFE_VX = 0.08;            // px/frame (was 0.15)
      const SAFE_ANGLE = 0.08;         // rad (was 0.12)

      // Explosion tuning
      const EXPLODE_PIECES = 26;
      const EXPLODE_TTL = 160;         // frames
      const EXPLODE_KICK = 1.9;        // velocity kick
      const EXPLODE_SPIN = 0.12;       // rad/frame

      // --- State
      let terrain = [];
      let lander = null;
      let message = null;
      let paused = false;

      // Explosion particles (line-segment shards)
      let shards = []; // {x,y,vx,vy,ang,spin,len,ttl}

      function rand(min, max) { return min + Math.random() * (max - min); }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // --- Terrain generation (midpoint displacement)
      function generateTerrain() {
        const segments = 128;
        const pts = new Array(segments + 1);
        const base = H * 0.78;

        pts[0] = base + rand(-40, 40);
        pts[segments] = base + rand(-40, 40);

        let step = segments;
        let rough = 140;
        while (step > 1) {
          for (let i = 0; i < segments; i += step) {
            const mid = i + step / 2;
            const a = pts[i];
            const b = pts[i + step];
            pts[mid] = (a + b) / 2 + rand(-rough, rough);
          }
          step /= 2;
          rough *= 0.55;
        }

        for (let i = 0; i < pts.length; i++) pts[i] = clamp(pts[i], H * 0.45, H * 0.92);
        for (let pass = 0; pass < 2; pass++) {
          for (let i = 1; i < pts.length - 1; i++) pts[i] = (pts[i - 1] + pts[i] + pts[i + 1]) / 3;
        }

        const out = [];
        for (let i = 0; i <= segments; i++) out.push({ x: (i / segments) * W, y: pts[i] });

        // Create 2-4 flat landing pads
        const numPads = Math.floor(rand(2, 5)); // 2, 3, or 4 pads
        const minPadSpacing = 150; // minimum distance between pads
        const pads = [];

        for (let attempt = 0; attempt < numPads * 10 && pads.length < numPads; attempt++) {
          const padW = rand(60, 140);
          const padX = rand(80, W - 80 - padW);

          // Check if this pad is far enough from existing pads
          let tooClose = false;
          for (const existingPad of pads) {
            if (Math.abs(existingPad.x - padX) < minPadSpacing || Math.abs((existingPad.x + existingPad.width) - padX) < minPadSpacing || Math.abs(existingPad.x - (padX + padW)) < minPadSpacing) {
              tooClose = true;
              break;
            }
          }

          if (!tooClose) {
            const yTarget = getTerrainY(out, padX + padW / 2);
            for (const p of out) if (p.x >= padX && p.x <= padX + padW) p.y = yTarget;
            pads.push({ x: padX, width: padW });
          }
        }

        return out;
      }

      function getTerrainSegmentIndex(terr, x) {
        const n = terr.length;
        const t = clamp(x, 0, W - 0.001);
        const step = W / (n - 1);
        return clamp(Math.floor(t / step), 0, n - 2);
      }

      function getTerrainY(terr, x) {
        const i = getTerrainSegmentIndex(terr, x);
        const a = terr[i], b = terr[i + 1];
        const t = (x - a.x) / (b.x - a.x);
        return a.y + (b.y - a.y) * t;
      }

      function getTerrainSlopeAngle(terr, x) {
        const i = getTerrainSegmentIndex(terr, x);
        const a = terr[i], b = terr[i + 1];
        return Math.atan2(b.y - a.y, b.x - a.x);
      }

      function normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }

      // --- Lander
      function resetLander() {
        lander = {
          x: W * 0.5,
          y: H * 0.18,
          vx: rand(-0.06, 0.06),
          vy: rand(0.0, 0.03),
          angle: rand(-0.2, 0.2),
          fuel: MAX_FUEL,
          alive: true,
          landed: false
        };
      }

      function startNewLevel() {
        terrain = generateTerrain();
        resetLander();
        shards = [];
        message = null;
        paused = false;
      }
      startNewLevel();

      const crashLines = [
        "You caused a 2 mile radius crater.",
        "NASA called. They want their module back. In pieces.",
        "The moon is now slightly flatter. Thanks.",
        "Congratulations: you invented lunar confetti.",
        "You landed... as a concept.",
        "68 to bad"
      ];
      const winLines = [
        "Butter-smooth touchdown. The moon approves.",
        "Perfect landing. Time for moon snacks.",
        "Nice! Gravity is impressed.",
        "Soft as a marshmallow. On the moon. Somehow.",
        "You stick the landing like a pro.",
        "Lunar landing: accomplished with style.",
        "67 to good"
      ];

      function showMessage(text, sub = "Press R for a new level") {
        message = { text, sub };
      }

      // --- Explosion
      function explodeAt(x, y, baseVx, baseVy) {
        shards = [];
        for (let i = 0; i < EXPLODE_PIECES; i++) {
          const a = rand(0, Math.PI * 2);
          const sp = rand(0.2, 1.0) * EXPLODE_KICK;
          shards.push({
            x, y,
            vx: baseVx + Math.cos(a) * sp,
            vy: baseVy + Math.sin(a) * sp,
            ang: rand(0, Math.PI * 2),
            spin: rand(-EXPLODE_SPIN, EXPLODE_SPIN),
            len: rand(6, 18),
            ttl: EXPLODE_TTL + (Math.random() * 40 | 0)
          });
        }
      }

      // --- Drawing
      function clear() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);
      }

      function drawTerrain() {
        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(terrain[0].x, terrain[0].y);
        for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].x, terrain[i].y);
        ctx.stroke();

        ctx.fillStyle = DIM;
        ctx.beginPath();
        ctx.moveTo(0, H);
        ctx.lineTo(terrain[0].x, terrain[0].y);
        for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].x, terrain[i].y);
        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fill();
      }

      function drawLander() {
        if (!lander.alive) return; // when crashed, only shards draw
        const { x, y, angle } = lander;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;

        // Hull
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(10, 10);
        ctx.lineTo(-10, 10);
        ctx.closePath();
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.moveTo(-8, 8);
        ctx.lineTo(-16, 16);
        ctx.moveTo(8, 8);
        ctx.lineTo(16, 16);
        ctx.stroke();

        // Cockpit
        ctx.beginPath();
        ctx.moveTo(-4, 2);
        ctx.lineTo(4, 2);
        ctx.stroke();

        // Thrust flame
        const thrusting = keys.has("Space") && lander.fuel > 0 && lander.alive && !lander.landed && !paused;
        if (thrusting) {
          ctx.strokeStyle = "#B6FFB6";
          ctx.beginPath();
          ctx.moveTo(0, 12);
          ctx.lineTo(rand(-3, 3), 22 + rand(0, 6));
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawShards() {
        if (shards.length === 0) return;
        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;

        for (const s of shards) {
          // fade slightly as ttl runs out
          const alpha = clamp(s.ttl / (EXPLODE_TTL + 40), 0, 1);
          ctx.globalAlpha = 0.35 + 0.65 * alpha;

          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(s.ang);

          ctx.beginPath();
          ctx.moveTo(-s.len / 2, 0);
          ctx.lineTo(s.len / 2, 0);
          ctx.stroke();

          // a tiny "spark" cross sometimes
          if ((s.ttl % 9) === 0) {
            ctx.beginPath();
            ctx.moveTo(0, -2);
            ctx.lineTo(0, 2);
            ctx.stroke();
          }

          ctx.restore();
        }
        ctx.globalAlpha = 1;
      }

      function drawHUD() {
        const fuel = Math.max(0, lander.fuel);
        const vx = lander.vx, vy = lander.vy;

        ctx.fillStyle = GREEN;
        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
        ctx.textBaseline = "top";

        ctx.fillText(`FUEL: ${fuel.toFixed(0)}`, 12, 10);
        ctx.fillText(`H-SPEED: ${vx.toFixed(3)}`, 12, 28);
        ctx.fillText(`V-SPEED: ${vy.toFixed(3)}`, 12, 46);

        if (paused) ctx.fillText("PAUSED (ESC to resume)", 12, 70);
      }

      function drawMessage() {
        if (!message) return;
        ctx.fillStyle = GREEN;
        ctx.font = '20px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(message.text, W / 2, H * 0.32);

        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
        ctx.fillText(message.sub, W / 2, H * 0.32 + 34);
        ctx.textAlign = "start";
      }

      // --- Physics / collision
      function checkCollisionAndLanding() {
        const footOffset = 16;
        const footX = lander.x + Math.sin(lander.angle) * footOffset;
        const footY = lander.y + Math.cos(lander.angle) * footOffset;

        const groundY = getTerrainY(terrain, clamp(footX, 0, W));
        if (footY >= groundY) {
          const slope = getTerrainSlopeAngle(terrain, clamp(footX, 0, W));

          const okVy = Math.abs(lander.vy) <= SAFE_VY;
          const okVx = Math.abs(lander.vx) <= SAFE_VX;

          const angleDiff = normalizeAngle(lander.angle - slope);
          const okAngle = Math.abs(angleDiff) <= SAFE_ANGLE;

          if (okVy && okVx && okAngle) {
            lander.landed = true;
            lander.alive = true;

            // Stick to surface
            lander.y -= (footY - groundY) + 0.5;
            lander.vx = 0; lander.vy = 0;

            showMessage(winLines[(Math.random() * winLines.length) | 0], "Press R for a new level (new hills)");
          } else {
            // Crash -> explode
            lander.alive = false;
            lander.landed = false;

            // snap to impact point for better explosion placement
            lander.y -= (footY - groundY) + 0.5;
            explodeAt(lander.x, lander.y, lander.vx, lander.vy);

            const why = (!okVy || !okVx) ? "Too fast." : "Not level.";
            showMessage(`${crashLines[(Math.random() * crashLines.length) | 0]} (${why})`, "Press R to retry (new hills)");
          }
        }
      }

      // --- Update
      function update() {
        if (paused) return;

        // Update shards even when dead
        if (shards.length) {
          for (const s of shards) {
            s.vy += GRAVITY * 60; // make shards fall a bit faster visually vs ultra-low gravity
            s.x += s.vx * 1.2;
            s.y += s.vy * 1.2;
            s.ang = normalizeAngle(s.ang + s.spin);
            s.ttl--;
          }
          shards = shards.filter(s => s.ttl > 0 && s.y < H + 80);

          // wrap shards horizontally
          for (const s of shards) {
            if (s.x < 0) s.x += W;
            if (s.x > W) s.x -= W;
          }
        }

        if (!lander.alive || lander.landed) return;

        if (keys.has("ArrowLeft")) lander.angle -= ROT_SPEED;
        if (keys.has("ArrowRight")) lander.angle += ROT_SPEED;
        lander.angle = normalizeAngle(lander.angle);

        const thrusting = keys.has("Space") && lander.fuel > 0;
        if (thrusting) {
          const ax = Math.sin(lander.angle) * THRUST;
          const ay = -Math.cos(lander.angle) * THRUST;
          lander.vx += ax;
          lander.vy += ay;
          lander.fuel = Math.max(0, lander.fuel - FUEL_BURN);
        }

        lander.vy += GRAVITY;

        lander.x += lander.vx;
        lander.y += lander.vy;

        if (lander.x < 0) lander.x += W;
        if (lander.x > W) lander.x -= W;
        if (lander.y < -50) lander.y = -50;

        checkCollisionAndLanding();
      }

      // --- Render
      function render() {
        ctx.imageSmoothingEnabled = false;
        clear();
        drawTerrain();
        drawShards();
        drawLander();
        drawHUD();
        drawMessage();
      }

      function loop() {
        update();
        render();
        requestAnimationFrame(loop);
      }
      loop();
    })();
  </script>
</body>

</html>