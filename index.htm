<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Retro Lunar Lander</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: auto;
      /* Changed for smoother glow */
    }

    .hint {
      position: fixed;
      left: 12px;
      right: 12px;
      /* Add right constraint */
      bottom: 24px;
      color: #8cff8c;
      font: 13px/1.4 ui-monospace, monospace;
      opacity: 0.9;
      user-select: none;
      text-shadow: 0 0 8px #00ff00, 0 0 12px rgba(0, 255, 0, 0.5);
      pointer-events: none;
      white-space: normal;
      overflow-wrap: break-word;
    }

    /* Start Overlay for iOS permission */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #7CFF7C;
      font: 20px ui-monospace, monospace;
      z-index: 100;
      text-align: center;
      padding: 20px;
    }

    #overlay button {
      background: transparent;
      border: 2px solid #7CFF7C;
      color: #7CFF7C;
      padding: 15px 30px;
      font: 20px ui-monospace, monospace;
      cursor: pointer;
      margin-top: 20px;
      box-shadow: 0 0 10px #7CFF7C;
    }

    #overlay button:hover {
      background: #7CFF7C;
      color: #000;
    }
  </style>
</head>

<body>
  <div id="overlay">
    <div>LUNAR LANDER</div>
    <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">TILT to ROTATE • TOUCH to THRUST</div>
    <button id="startBtn">START MISSION</button>
  </div>
  <canvas id="c"></canvas>
  <div class="hint">←/→ rotate • SPACE thrust • R retry • ESC pause</div>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      // --- State & Variables
      let W, H;
      let terrain = [];
      let lander = null;
      let message = null;
      let paused = false;
      let shards = []; // {x,y,vx,vy,ang,spin,len,ttl}

      // --- Resize (responsive)
      function resize() {
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener("resize", resize);
      resize();

      // --- Input
      const keys = new Set();
      let touchThrust = 0; // Use a counter to make it linger for visibility
      let tiltAngle = 0;

      function handleInput() {
        window.addEventListener("keydown", (e) => {
          if (["ArrowLeft", "ArrowRight", "Space", "Escape", "KeyR"].includes(e.code)) e.preventDefault();
          keys.add(e.code);
          if (e.code === "Escape") paused = !paused;
          if (e.code === "KeyR") startNewLevel();
        });
        window.addEventListener("keyup", (e) => keys.delete(e.code));

        // Touch controls
        window.addEventListener("touchstart", (e) => {
          if (e.target === startBtn) return;
          e.preventDefault();
          if (lander && lander.alive && !lander.landed) touchThrust = 1;
          if (message) startNewLevel();
        }, { passive: false });
        window.addEventListener("touchend", (e) => {
          touchThrust = 0;
        });
        // Mouse for desktop test of touch logic
        window.addEventListener("mousedown", (e) => {
          if (e.target === startBtn) return;
          if (lander && lander.alive && !lander.landed) touchThrust = 1;
          if (message) startNewLevel();
        });
        window.addEventListener("mouseup", (e) => {
          touchThrust = 0;
        });

        // Device Orientation (Tilt)
        window.addEventListener("deviceorientation", (e) => {
          // beta is tilt front/back, gamma is tilt left/right
          // We want gamma for rotation (assuming landscape or portrait)
          let g = e.gamma;
          if (window.innerHeight > window.innerWidth) {
            // Portrait: gamma is left/right tilt [-90, 90]
            tiltAngle = clamp(g / 30, -1, 1); // Sensitivity
          } else {
            // Landscape: beta might be more appropriate depending on orientation
            tiltAngle = clamp(e.beta / 30, -1, 1);
          }
        });
      }

      // iOS Permission Request
      const startBtn = document.getElementById("startBtn");
      const overlay = document.getElementById("overlay");
      startBtn.addEventListener("click", () => {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                handleInput();
              } else {
                handleInput(); // Fallback to touch only
              }
            })
            .catch(console.error);
        } else {
          handleInput(); // Non-iOS or older
        }
        overlay.style.display = "none";
        startNewLevel();
      });

      // --- Game constants (YOUR DEFAULTS)
      const GREEN = "#7CFF7C";
      const DIM = "rgba(124,255,124,0.15)";
      const GRAVITY = 0.0009;          // px/frame^2
      const ROT_SPEED = 0.005;         // rad/frame
      const THRUST = 0.002;            // acceleration magnitude
      const FUEL_BURN = 1.8;           // per frame while thrusting
      const MAX_FUEL = 100000;

      const SAFE_VY = 0.08;            // px/frame (was 0.15)
      const SAFE_VX = 0.08;            // px/frame (was 0.15)
      const SAFE_ANGLE = 0.08;         // rad (was 0.12)

      // Explosion tuning
      const EXPLODE_PIECES = 26;
      const EXPLODE_TTL = 160;         // frames
      const EXPLODE_KICK = 1.9;        // velocity kick
      const EXPLODE_SPIN = 0.12;       // rad/frame

      function rand(min, max) { return min + Math.random() * (max - min); }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // --- Terrain generation (midpoint displacement)
      function generateTerrain() {
        const segments = Math.max(64, Math.floor(W / 12)); // Responsive segments
        const pts = new Array(segments + 1);
        const base = H * 0.78;

        pts[0] = base + rand(-40, 40);
        pts[segments] = base + rand(-40, 40);

        let step = segments;
        let rough = 140;
        while (step > 1) {
          for (let i = 0; i < segments; i += step) {
            const mid = i + step / 2;
            const a = pts[i];
            const b = pts[i + step];
            pts[mid] = (a + b) / 2 + rand(-rough, rough);
          }
          step /= 2;
          rough *= 0.55;
        }

        for (let i = 0; i < pts.length; i++) pts[i] = clamp(pts[i], H * 0.45, H * 0.92);
        for (let pass = 0; pass < 2; pass++) {
          for (let i = 1; i < pts.length - 1; i++) pts[i] = (pts[i - 1] + pts[i] + pts[i + 1]) / 3;
        }

        const out = [];
        for (let i = 0; i <= segments; i++) out.push({ xf: i / segments, yf: pts[i] / H });

        // Create landing pads
        const numPads = Math.floor(rand(2, 5));
        const pads = [];

        for (let attempt = 0; attempt < 30 && pads.length < numPads; attempt++) {
          const padWF = rand(0.06, 0.12);
          const padXF = rand(0.1, 0.9 - padWF);

          const yTargetF = getTerrainY(out, padXF * W) / H;
          for (const p of out) {
            if (p.xf >= padXF && p.xf <= padXF + padWF) p.yf = yTargetF;
          }
          pads.push({ xf: padXF, wf: padWF });
        }

        return out;
      }

      function getTerrainY(terr, x) {
        const xf = clamp(x, 0, W - 0.001) / W;
        const n = terr.length;
        const i = clamp(Math.floor(xf * (n - 1)), 0, n - 2);
        const a = terr[i], b = terr[i + 1];
        const t = (xf - a.xf) / (b.xf - a.xf);
        return (a.yf + (b.yf - a.yf) * t) * H;
      }

      function getTerrainSlopeAngle(terr, x) {
        const xf = clamp(x, 0, W - 0.001) / W;
        const n = terr.length;
        const i = clamp(Math.floor(xf * (n - 1)), 0, n - 2);
        const a = terr[i], b = terr[i + 1];
        return Math.atan2((b.yf - a.yf) * H, (b.xf - a.xf) * W);
      }

      function normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }

      // --- Lander
      function resetLander() {
        lander = {
          x: W * 0.5,
          y: H * 0.18,
          vx: rand(-0.06, 0.06),
          vy: rand(0.0, 0.03),
          angle: rand(-0.2, 0.2),
          fuel: MAX_FUEL,
          alive: true,
          landed: false
        };
      }

      function startNewLevel() {
        terrain = generateTerrain();
        resetLander();
        shards = [];
        message = null;
        paused = false;
      }
      startNewLevel();

      const crashLines = [
        "You caused a 2 mile radius crater.",
        "NASA called. They want their module back. In pieces.",
        "The moon is now slightly flatter. Thanks.",
        "Congratulations: you invented lunar confetti.",
        "You landed... as a concept.",
        "68 to bad"
      ];
      const winLines = [
        "Butter-smooth touchdown. The moon approves.",
        "Perfect landing. Time for moon snacks.",
        "Nice! Gravity is impressed.",
        "Soft as a marshmallow. On the moon. Somehow.",
        "You stick the landing like a pro.",
        "Lunar landing: accomplished with style.",
        "67 to good"
      ];

      function showMessage(text, sub = "Press R for a new level") {
        message = { text, sub };
      }

      // --- Explosion
      function explodeAt(x, y, baseVx, baseVy) {
        shards = [];
        for (let i = 0; i < EXPLODE_PIECES; i++) {
          const a = rand(0, Math.PI * 2);
          const sp = rand(0.2, 1.0) * EXPLODE_KICK;
          shards.push({
            x, y,
            vx: baseVx + Math.cos(a) * sp,
            vy: baseVy + Math.sin(a) * sp,
            ang: rand(0, Math.PI * 2),
            spin: rand(-EXPLODE_SPIN, EXPLODE_SPIN),
            len: rand(6, 18),
            ttl: EXPLODE_TTL + (Math.random() * 40 | 0)
          });
        }
      }

      // --- Drawing
      function clear() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);
      }

      function drawTerrain() {
        if (!terrain || terrain.length === 0) return;
        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 12;
        ctx.shadowColor = GREEN;
        ctx.beginPath();
        ctx.moveTo(terrain[0].xf * W, terrain[0].yf * H);
        for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].xf * W, terrain[i].yf * H);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = DIM;
        ctx.beginPath();
        ctx.moveTo(0, H);
        ctx.lineTo(terrain[0].xf * W, terrain[0].yf * H);
        for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].xf * W, terrain[i].yf * H);
        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fill();
      }

      function drawLander() {
        if (!lander.alive) return; // when crashed, only shards draw
        const { x, y, angle } = lander;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = GREEN;

        // Hull
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(10, 10);
        ctx.lineTo(-10, 10);
        ctx.closePath();
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.moveTo(-8, 8);
        ctx.lineTo(-16, 16);
        ctx.moveTo(8, 8);
        ctx.lineTo(16, 16);
        ctx.stroke();

        // Cockpit
        ctx.beginPath();
        ctx.moveTo(-4, 2);
        ctx.lineTo(4, 2);
        ctx.stroke();

        // Thrust flame
        const isThrusting = (keys.has("Space") || touchThrust > 0) && lander.fuel > 0 && lander.alive && !lander.landed && !paused;
        if (isThrusting) {
          ctx.strokeStyle = "#B6FFB6";
          ctx.lineWidth = 3; // Thicker flame
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#B6FFB6";
          ctx.beginPath();
          ctx.moveTo(0, 10); // Start closer to hull
          ctx.lineTo(rand(-4, 4), 28 + rand(0, 8)); // Longer flame
          ctx.stroke();
          ctx.lineWidth = 2; // Reset
        }

        ctx.restore();
      }

      function drawShards() {
        if (shards.length === 0) return;
        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 8;
        ctx.shadowColor = GREEN;

        for (const s of shards) {
          // fade slightly as ttl runs out
          const alpha = clamp(s.ttl / (EXPLODE_TTL + 40), 0, 1);
          ctx.globalAlpha = 0.35 + 0.65 * alpha;

          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(s.ang);

          ctx.beginPath();
          ctx.moveTo(-s.len / 2, 0);
          ctx.lineTo(s.len / 2, 0);
          ctx.stroke();

          // a tiny "spark" cross sometimes
          if ((s.ttl % 9) === 0) {
            ctx.beginPath();
            ctx.moveTo(0, -2);
            ctx.lineTo(0, 2);
            ctx.stroke();
          }

          ctx.restore();
        }
        ctx.globalAlpha = 1;
      }

      function drawHUD() {
        const fuel = Math.max(0, lander.fuel);
        const vx = lander.vx, vy = lander.vy;
        const fontSize = Math.max(10, Math.min(14, W / 40));

        ctx.fillStyle = GREEN;
        ctx.shadowBlur = 5;
        ctx.shadowColor = GREEN;
        ctx.font = `${fontSize}px ui-monospace, monospace`;
        ctx.textBaseline = "top";
        ctx.textAlign = "start";

        ctx.fillText(`FUEL: ${fuel.toFixed(0)}`, 12, 10);
        ctx.fillText(`H-S: ${vx.toFixed(2)}`, 12, 10 + fontSize * 1.5);
        ctx.fillText(`V-S: ${vy.toFixed(2)}`, 12, 10 + fontSize * 3.0);

        if (paused) ctx.fillText("PAUSED", 12, 10 + fontSize * 5.0);
      }

      function drawMessage() {
        if (!message) return;
        const titleSize = Math.max(16, Math.min(24, W / 20));
        const subSize = Math.max(12, Math.min(16, W / 30));

        ctx.fillStyle = GREEN;
        ctx.textAlign = "center";

        ctx.font = `${titleSize}px ui-monospace, monospace`;
        ctx.fillText(message.text, W / 2, H * 0.32);

        ctx.font = `${subSize}px ui-monospace, monospace`;
        ctx.fillText(message.sub, W / 2, H * 0.32 + titleSize + 10);
        ctx.textAlign = "start";
      }

      // --- Physics / collision
      function checkCollisionAndLanding() {
        const footOffset = 16;
        const footX = lander.x + Math.sin(lander.angle) * footOffset;
        const footY = lander.y + Math.cos(lander.angle) * footOffset;

        const groundY = getTerrainY(terrain, clamp(footX, 0, W));
        if (footY >= groundY) {
          const slope = getTerrainSlopeAngle(terrain, clamp(footX, 0, W));

          const okVy = Math.abs(lander.vy) <= SAFE_VY;
          const okVx = Math.abs(lander.vx) <= SAFE_VX;

          const angleDiff = normalizeAngle(lander.angle - slope);
          const okAngle = Math.abs(angleDiff) <= SAFE_ANGLE;

          if (okVy && okVx && okAngle) {
            lander.landed = true;
            lander.alive = true;

            // Stick to surface
            lander.y -= (footY - groundY) + 0.5;
            lander.vx = 0; lander.vy = 0;

            showMessage(winLines[(Math.random() * winLines.length) | 0], "Press R for a new level (new hills)");
          } else {
            // Crash -> explode
            lander.alive = false;
            lander.landed = false;

            // snap to impact point for better explosion placement
            lander.y -= (footY - groundY) + 0.5;
            explodeAt(lander.x, lander.y, lander.vx, lander.vy);

            const why = (!okVy || !okVx) ? "Too fast." : "Not level.";
            showMessage(`${crashLines[(Math.random() * crashLines.length) | 0]} (${why})`, "Press R to retry (new hills)");
          }
        }
      }

      // --- Update
      function update() {
        if (paused || !lander) return;

        // Update shards even when dead
        if (shards.length) {
          for (const s of shards) {
            s.vy += GRAVITY * 60; // make shards fall a bit faster visually vs ultra-low gravity
            s.x += s.vx * 1.2;
            s.y += s.vy * 1.2;
            s.ang = normalizeAngle(s.ang + s.spin);
            s.ttl--;
          }
          shards = shards.filter(s => s.ttl > 0 && s.y < H + 80);

          // wrap shards horizontally
          for (const s of shards) {
            if (s.x < 0) s.x += W;
            if (s.x > W) s.x -= W;
          }
        }

        if (!lander.alive || lander.landed) return;

        if (keys.has("ArrowLeft")) lander.angle -= ROT_SPEED;
        if (keys.has("ArrowRight")) lander.angle += ROT_SPEED;

        // Mobile tilt control
        if (Math.abs(tiltAngle) > 0.1) {
          lander.angle += tiltAngle * ROT_SPEED * 2;
        }

        lander.angle = normalizeAngle(lander.angle);

        const thrusting = (keys.has("Space") || touchThrust > 0) && lander.fuel > 0;
        if (thrusting) {
          const ax = Math.sin(lander.angle) * THRUST;
          const ay = -Math.cos(lander.angle) * THRUST;
          lander.vx += ax;
          lander.vy += ay;
          lander.fuel = Math.max(0, lander.fuel - FUEL_BURN);
        }

        lander.vy += GRAVITY;

        lander.x += lander.vx;
        lander.y += lander.vy;

        if (lander.x < 0) lander.x += W;
        if (lander.x > W) lander.x -= W;
        if (lander.y < -50) lander.y = -50;

        checkCollisionAndLanding();
      }

      // --- Render
      function render() {
        ctx.imageSmoothingEnabled = false;
        clear();
        drawTerrain();
        drawShards();
        if (lander) drawLander();
        if (lander) drawHUD();
        drawMessage();
      }

      function loop() {
        update();
        render();
        requestAnimationFrame(loop);
      }
      loop();
    })();
  </script>
</body>

</html>